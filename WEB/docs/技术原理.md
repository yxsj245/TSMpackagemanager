# ChatGPT
本程序核心代码方法均采用世界领先的人工智能生成辅助，让程序采用最前沿的技术，确保程序可靠稳定没有BUG。事实证明程序经过4次版本更新均没有任何BUG！3.0版本中引入众多功能和改进仍然从测试开始到正式过程中仍然也没有任何bug，做到新的功能增加而不影响以前的功能。
![](https://img.picui.cn/free/2024/10/12/6709fb212355d.png)
# 一键安装或更新
## 下载文件
在代码中虽然没有直接展示下载文件的部分，但通常可以通过 `requests.get()` 或类似函数来实现。一个常见的下载文件代码结构如下：
```python
def download_file_with_progress(url, save_path):
    with requests.get(url, stream=True) as r:
        r.raise_for_status()  # 检查请求是否成功
        with open(save_path, 'wb') as f:
            for chunk in r.iter_content(chunk_size=8192):  # 按块读取
                if chunk:  # 过滤掉空数据块
                    f.write(chunk)

```
这种结构会从URL逐块读取文件并保存到指定路径中，同时处理下载的过程中的网络问题。

## 校验文件
校验文件的代码核心在于**MD5校验**，确保下载后的文件与预期的一致。这一过程防止文件损坏、下载错误或被篡改。
```python
# 获取JSON数据
url = downdata['check'][1]
json_data = fetch_json_from_url(url)

# 如果成功获取到JSON数据，则进行文件校验
if json_data:
    for item in json_data:
        filename = item.get("filename")
        expected_md5 = item.get("md5")

        if filename and expected_md5:
            file_path = os.path.join(base_path, filename)  # 拼接基础路径和文件名
            if verify_md5(file_path, expected_md5):
                None  # MD5校验成功，不做任何处理
            else:
                sys.exit(1)  # 如果MD5不匹配，终止程序
        else:
            print(Fore.RED + "ERROR:JSON数据中缺少文件名或MD5值，跳过该项。")

print(Fore.BLUE + "INFO:文件信息校验完毕。")
```
- `downdata['check'][1]` 是保存文件校验信息的JSON数据的URL，通常该JSON文件包含多个文件的文件名和对应的MD5值。
- `fetch_json_from_url(url)` 函数通过网络请求从该URL获取JSON数据（包含文件名和MD5校验值），返回的数据结构通常为列表或字典，里面有文件名和MD5哈希值。
### `verify_md5`函数
该函数的任务是计算指定文件的MD5值，并将其与预期的MD5进行比较。以下是一个典型的MD5校验函数示例：
```python
    import hashlib
    def verify_md5(file_path, expected_md5):
        hash_md5 = hashlib.md5()
        try:
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):  # 按块读取文件
                    hash_md5.update(chunk)  # 更新MD5计算
        except FileNotFoundError:
            print(f"ERROR: 文件 {file_path} 未找到。")
            return False

        # 计算完毕后，将结果与预期的MD5值进行比较
        calculated_md5 = hash_md5.hexdigest()  # 获取文件的MD5哈希值
        return calculated_md5 == expected_md5
```
`verify_md5` 函数的工作原理:
1. 读取文件: 使用 `with open(file_path, "rb")` 以二进制模式打开文件，并通过 iter() 按块（例如4096字节）读取文件。分块读取大文件可以避免内存占用过高。
2. MD5计算: 使用 `hashlib.md5()` 创建一个MD5哈希对象，通过 update() 方法不断更新哈希值，直至文件读取完成。
3. 哈希对比: 计算文件的最终MD5值 `hash_md5.hexdigest()`，并将其与预期值 `expected_md5` 进行对比。
4. 错误处理: 如果文件未找到或读取过程中发生错误，函数会返回 `False`，并输出错误信息。
### MD5校验的意义
MD5校验常用于文件完整性验证，因为它能够为任意大小的文件生成唯一的哈希值。如果文件在传输过程中损坏或被篡改，即使是极小的变化（如一个字节的不同），MD5哈希值也会发生显著变化。通过比较MD5哈希值，可以有效验证下载的文件是否与预期一致。
## `unzip_file()`(解压文件)函数
```python
    import zipfile

    def unzip_file(zip_path, extract_to):
        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_to)  # 解压到指定目录
            print(f"INFO: 成功解压文件 {zip_path} 到 {extract_to}")
        except zipfile.BadZipFile:
            print(f"ERROR: 文件 {zip_path} 是无效的 ZIP 文件。")
        except FileNotFoundError:
            print(f"ERROR: 找不到文件 {zip_path}。")
        except Exception as e:
            print(f"ERROR: 解压文件 {zip_path} 时发生错误: {e}")
```
### 工作原理:
- 输入:
 - `zip_path`: 压缩文件的完整路径。
extract_to: 解压的目标目录（通常是游戏的安装目录或资源文件夹）。
 - 输出:
将ZIP文件中的内容解压到指定的 `extract_to` 目录。
### 主要逻辑:
1. 打开ZIP文件:

- 使用 `with zipfile.ZipFile(zip_path, 'r') as zip_ref` 打开指定路径的ZIP压缩文件。
`zipfile.ZipFile` 是Python标准库 zipfile 模块中的类，用于处理`ZIP`文件。参数 `'r'` 表示以读取模式打开文件。
2. 解压文件:
 - `zip_ref.extractall(extract_to)` 解压所有文件到指定的目录 `extract_to`。
 - `extractall()` 方法会自动解压缩ZIP文件中的所有内容并将它们保存到目标目录。
3. 错误处理:

 - `except zipfile.BadZipFile` 用于捕获无效或损坏的ZIP文件异常，防止程序崩溃，并输出错误提示。
 - `except FileNotFoundError` 捕获文件不存在的异常，如果程序找不到指定的`ZIP`文件，则输出错误提示。
 - `except Exception as e` 捕获任何其他可能发生的异常并打印错误信息，以便调试或排查问题。
4. 成功提示:
 - 当文件成功解压后，程序会输出 `INFO` 提示，告知用户解压完成，并提供压缩文件的路径和解压到的目标目录。

# 故障排除
按照用户选择：`游戏启动后没有显示任何窗口`\
 - 这种一般是由于缺少VC运行库，所以我会下载VC并执行安装
    ```python
    if xuanze == '1':
        print(Fore.BLUE + "INFO:开始下载VC运行库,稍后请点击安装后重启电脑再次尝试启动游戏")
        fileurl = down_5
        save_path = os.path.join(filepath, "VC_redist.x64.exe")
        download_file_with_progress(fileurl, save_path)
        exe_path = os.path.join(filepath, "VC_redist.x64.exe")
        subprocess.run(exe_path)
    ```
    使用 down_5 作为文件下载的URL。\
将下载的文件保存到指定路径 `save_path`。
下载文件后使用 `subprocess.run()` 执行该安装程序。
用户安装后需要重启电脑再次尝试启动游戏。\

`游戏启动后出现游戏窗口但很快消失`这种按照TSM作者所示删除demo.dll 但是实际情况并没有什么用
```python
else:
    try:
        os.remove(os.path.join(game_path, 'mods', 'demo.dll'))
    except FileNotFoundError:
        print(Fore.RED + 'ERROR:文件不存在：可能您已运行过此解决方案')
        input()
        sys.exit(1)
```
# 监控游戏进程
这部分的功能函数主要是用于判断游戏是否按照预期成功启动，以便决定是否启动`故障排除`
## 无限循环检测进程
```python
while True:
    process_exists = any(proc.name() == process_name for proc in psutil.process_iter())
```
- 这段代码使用 `psutil.process_iter()` 遍历当前所有正在运行的进程，并检查其中是否有名为 `Sky.exe` 的进程。
- `any()` 函数会在找到一个符合条件的进程后立即返回 `True`，否则返回 `False`。
- 该部分代码运行在一个 `while True` 无限循环中，直到检测到目标进程为止。
## 检测到进程后计时20秒
```python
if process_exists:
    print(f"检测到 {process_name}，开始计时20秒")
    start_time = time.time()
```
一旦检测到 `Sky.exe` 进程，程序会输出提示，并记录当前时间 `start_time`，为后续的20秒计时做准备。
##  监控进程20秒
```python
while time.time() - start_time < 20:
    process_exists = any(proc.name() == process_name for proc in psutil.process_iter())

    if not process_exists:
        print(f"{process_name} 已退出")
        return True  # 返回成功，进程在20秒内退出
```
- 进入一个新的 `while` 循环，在接下来的20秒内每秒检查一次进程是否仍然存在。
- 如果在20秒内进程消失，输出 `"{process_name} `已退出"，并返回 `True`，表示进程在这段时间内已正常退出。
## 20秒内进程未退出
```python
print(f"{process_name} 在20秒内未退出")
return False  # 返回失败，进程未在20秒内退出
```
- 如果20秒计时结束且 `Sky.exe` 进程仍然存在，则输出提示，表示进程在20秒内未退出，并返回 `False`，意味着进程运行时间超出了预期。
## 未检测到进程的情况下
```python
else:
    time.sleep(1)
```
- 如果未检测到 `Sky.exe` 进程，程序会暂停1秒，然后继续下一轮的检查。这确保了代码不会一直占用CPU资源，并定期检查目标进程的存在情况。

# 彻底卸载TSM
与标准卸载不同，彻底卸载用的是`排除法`，只检测游戏根目录的文件(不递归)排除与Sky不相关的文件全部删除
> 随着Sky的版本更新，可能在根目录文件多出其他文件，这个时候包管理器需要进行适配兼容，否则会导致游戏文件损坏，所以此功能不推荐标准安装TSM的用户使用
```python
def delete_feifiles_and_directories_with_confirmation(target_directory):
    # 不删除的文件和文件夹
    files_to_keep = [
        "steam_api64.dll", "Sky.res", "Sky.log", "Sky.lib",
        "Sky.exe", "fmodstudio.dll", "fmod.dll", "crashpad_handler.exe"
    ]

    directories_to_keep = [
        "data", "crash_reports"
    ]

    # 收集所有将要删除的文件和文件夹
    files_to_delete = []
    directories_to_delete = []

    # 遍历目标目录中的所有文件和文件夹
    for root, dirs, files in os.walk(target_directory):
        # 检查当前目录是否在保留的文件夹中
        dirs[:] = [d for d in dirs if d not in directories_to_keep]

        # 遍历文件，排除保留文件
        for file_name in files:
            if file_name not in files_to_keep:
                files_to_delete.append(os.path.join(root, file_name))

        # 只添加不在保留列表中的目录，并忽略目录内的内容
        for dir_name in dirs:
            directories_to_delete.append(os.path.join(root, dir_name))
        # 跳过深入遍历这些目录
        dirs[:] = []

    # 提示用户确认
    print("以下文件和目录将被删除:")
    print("\n文件:")
    for file_path in files_to_delete:
        print(file_path)
    print("\n目录:")
    for dir_path in directories_to_delete:
        print(dir_path)

    confirmation = input("确认删除这些文件和目录吗？(y/n): ").lower()
    if confirmation != 'y':
        print("取消删除操作。")
        return

    # 删除文件
    for file_path in files_to_delete:
        try:
            if os.path.isfile(file_path):
                os.remove(file_path)
                print(Fore.BLUE + f"INFO: 已删除文件: {file_path}")
            else:
                print(Fore.RED+f"ERROR: 文件未找到: {file_path}")
        except Exception as e:
            print(Fore.RED+f"ERROR: 删除文件时出错: {file_path}, 错误: {e}")

    # 删除目录
    for dir_path in directories_to_delete:
        try:
            if os.path.isdir(dir_path):
                shutil.rmtree(dir_path)
                print(Fore.BLUE + f"INFO: 已删除目录: {dir_path}")
            else:
                print(Fore.RED+f"ERROR: 目录未找到: {dir_path}")
        except Exception as e:
            print(Fore.RED+f"ERROR: 删除目录时出错: {dir_path}, 错误: {e}")
```
# 社区功能
由于作者不会写UI，这部分代码全部采用ChatGPT\
这段代码主要是为一个基于Tkinter图形界面的应用程序创建的。它通过从远程URL或本地文件中获取JSON数据，并动态生成界面让用户可以下载文件并监控下载进度。下面我将详细讲解这部分代码的结构和功能：
## 从URL获取JSON数据的函数
```python
def fetch_data_from_url(url):
    try:
        response = requests.get(url)
        response.raise_for_status()  # 确保请求成功
        return response.json()
    except requests.exceptions.RequestException as e:
        messagebox.showerror("Error", f"Failed to fetch data from URL: {e}")
        return None
```
- 功能：该函数尝试通过GET请求从给定的URL获取JSON数据。如果请求失败，会显示一个错误弹窗，并返回 `None`。
- 异常处理：使用 `try-except` 捕获请求异常，防止程序崩溃。
## 带进度条的文件下载函数
```python
def download_file_with_progress(url, save_path, progress_bar, root, install_button):
    try:
        response = requests.get(url, stream=True, allow_redirects=True)
        response.raise_for_status()

        content_type = response.headers.get('Content-Type')
        if 'text/html' in content_type:
            messagebox.showerror("Error", "请求返回了HTML内容，可能URL无效或需要权限。")
            return

        total_size = int(response.headers.get('content-length', 0))
        progress_bar["maximum"] = total_size

        os.makedirs(os.path.dirname(save_path), exist_ok=True)

        with open(save_path, 'wb') as file:
            for chunk in response.iter_content(chunk_size=8192):
                file.write(chunk)
                progress_bar["value"] += len(chunk)
                root.update_idletasks()

        messagebox.showinfo("完成", f"文件已下载并安装,请重启游戏生效。")
    except requests.exceptions.RequestException as e:
        messagebox.showerror("Error", f"下载文件时出错: {e}")
    finally:
        install_button.config(state=tk.NORMAL, text="安装")
```
- 功能：通过指定的URL下载文件，显示下载进度，并在完成后显示成功消息。
- 进度条更新：通过 `progress_bar["value"]` 实时更新下载进度条。
- 异常处理：处理网络异常，如果请求失败，会显示错误弹窗。
## 安装文件的函数
```python
def install_application(down, puth, progress_bar, root, install_button):
    progress_bar["value"] = 0
    decoded_filename = unquote(down.split('/')[-1])  # 解码文件名中的百分号
    save_path = os.path.join(puth, decoded_filename)

    install_button.config(state=tk.DISABLED, text="正在下载...")

    download_thread = threading.Thread(target=download_file_with_progress,
                                       args=(down, save_path, progress_bar, root, install_button))
    download_thread.start()
```
- 功能：启动一个新线程下载文件，以避免阻塞主界面。下载时禁用按钮，并更新按钮的文字显示为“正在下载”。
- 文件保存路径：通过解码URL中的文件名确定文件保存路径。
## 创建Tkinter图形界面的函数
```python
def create_interface(data):
    root = tk.Tk()
    root.title("动态 JSON 数据界面")

    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()

    window_width = int(screen_width * 0.3)
    window_height = int(screen_height * 0.3)
    root.geometry(f"{window_width}x{window_height}")

    canvas = tk.Canvas(root)
    scrollbar = ttk.Scrollbar(root, orient="vertical", command=canvas.yview)
    scrollable_frame = ttk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(
            scrollregion=canvas.bbox("all")
        )
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    row_counter = 0

    for entry in data:
        name = entry.get("name", "No Name")
        txt = entry.get("txt", "No Description")
        down = entry.get("down", "")
        puth = entry.get("puth", "")
        puth = game_path + puth

        ttk.Label(scrollable_frame, text=f"名称: {name}").grid(row=row_counter, column=0, sticky=tk.W, pady=2)
        ttk.Label(scrollable_frame, text=f"描述: {txt}").grid(row=row_counter + 1, column=0, sticky=tk.W, pady=2)

        progress_bar = ttk.Progressbar(scrollable_frame, orient="horizontal", length=200, mode="determinate")
        progress_bar.grid(row=row_counter + 4, column=0, pady=5)

        install_button = ttk.Button(scrollable_frame, text="安装")
        install_button.config(
            command=lambda d=down, p=puth, pb=progress_bar, ib=install_button: install_application(d, p, pb, root, ib))
        install_button.grid(row=row_counter + 5, column=0, pady=10)

        row_counter += 6

    root.mainloop()
```
- 功能：创建一个包含滚动条的界面，展示从JSON数据中提取的信息，并为每个项目生成安装按钮和进度条。
- 界面布局：通过 `Tkinter` 和 `ttk` 实现，包含滚动区域，使用户可以浏览多条数据。